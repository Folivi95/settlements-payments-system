// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/saltpay/settlements-payments-system/internal/domain/ports"
	"sync"
)

// Ensure, that FeatureFlagServiceMock does implement ports.FeatureFlagService.
// If this is not the case, regenerate this file with moq.
var _ ports.FeatureFlagService = &FeatureFlagServiceMock{}

// FeatureFlagServiceMock is a mock implementation of ports.FeatureFlagService.
//
//	func TestSomethingThatUsesFeatureFlagService(t *testing.T) {
//
//		// make and configure a mocked ports.FeatureFlagService
//		mockedFeatureFlagService := &FeatureFlagServiceMock{
//			IsIngestionEnabledFromBankingCircleUncheckedQueueFunc: func() bool {
//				panic("mock out the IsIngestionEnabledFromBankingCircleUncheckedQueue method")
//			},
//			IsIngestionEnabledFromBankingCircleUnprocessedQueueFunc: func() bool {
//				panic("mock out the IsIngestionEnabledFromBankingCircleUnprocessedQueue method")
//			},
//			IsIngestionEnabledFromUfxFileNotificationQueueFunc: func() bool {
//				panic("mock out the IsIngestionEnabledFromUfxFileNotificationQueue method")
//			},
//			IsKafkaIngestionEnabledForPaymentTransactionsFunc: func() bool {
//				panic("mock out the IsKafkaIngestionEnabledForPaymentTransactions method")
//			},
//			IsKafkaPublishingEnableForAcquiringHostTransactionsFunc: func() bool {
//				panic("mock out the IsKafkaPublishingEnableForAcquiringHostTransactions method")
//			},
//			ToggleOffIngestionFromBankingCirclePaymentsFunc: func(ctx context.Context) error {
//				panic("mock out the ToggleOffIngestionFromBankingCirclePayments method")
//			},
//		}
//
//		// use mockedFeatureFlagService in code that requires ports.FeatureFlagService
//		// and then make assertions.
//
//	}
type FeatureFlagServiceMock struct {
	// IsIngestionEnabledFromBankingCircleUncheckedQueueFunc mocks the IsIngestionEnabledFromBankingCircleUncheckedQueue method.
	IsIngestionEnabledFromBankingCircleUncheckedQueueFunc func() bool

	// IsIngestionEnabledFromBankingCircleUnprocessedQueueFunc mocks the IsIngestionEnabledFromBankingCircleUnprocessedQueue method.
	IsIngestionEnabledFromBankingCircleUnprocessedQueueFunc func() bool

	// IsIngestionEnabledFromUfxFileNotificationQueueFunc mocks the IsIngestionEnabledFromUfxFileNotificationQueue method.
	IsIngestionEnabledFromUfxFileNotificationQueueFunc func() bool

	// IsKafkaIngestionEnabledForPaymentTransactionsFunc mocks the IsKafkaIngestionEnabledForPaymentTransactions method.
	IsKafkaIngestionEnabledForPaymentTransactionsFunc func() bool

	// IsKafkaPublishingEnableForAcquiringHostTransactionsFunc mocks the IsKafkaPublishingEnableForAcquiringHostTransactions method.
	IsKafkaPublishingEnableForAcquiringHostTransactionsFunc func() bool

	// ToggleOffIngestionFromBankingCirclePaymentsFunc mocks the ToggleOffIngestionFromBankingCirclePayments method.
	ToggleOffIngestionFromBankingCirclePaymentsFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// IsIngestionEnabledFromBankingCircleUncheckedQueue holds details about calls to the IsIngestionEnabledFromBankingCircleUncheckedQueue method.
		IsIngestionEnabledFromBankingCircleUncheckedQueue []struct {
		}
		// IsIngestionEnabledFromBankingCircleUnprocessedQueue holds details about calls to the IsIngestionEnabledFromBankingCircleUnprocessedQueue method.
		IsIngestionEnabledFromBankingCircleUnprocessedQueue []struct {
		}
		// IsIngestionEnabledFromUfxFileNotificationQueue holds details about calls to the IsIngestionEnabledFromUfxFileNotificationQueue method.
		IsIngestionEnabledFromUfxFileNotificationQueue []struct {
		}
		// IsKafkaIngestionEnabledForPaymentTransactions holds details about calls to the IsKafkaIngestionEnabledForPaymentTransactions method.
		IsKafkaIngestionEnabledForPaymentTransactions []struct {
		}
		// IsKafkaPublishingEnableForAcquiringHostTransactions holds details about calls to the IsKafkaPublishingEnableForAcquiringHostTransactions method.
		IsKafkaPublishingEnableForAcquiringHostTransactions []struct {
		}
		// ToggleOffIngestionFromBankingCirclePayments holds details about calls to the ToggleOffIngestionFromBankingCirclePayments method.
		ToggleOffIngestionFromBankingCirclePayments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockIsIngestionEnabledFromBankingCircleUncheckedQueue   sync.RWMutex
	lockIsIngestionEnabledFromBankingCircleUnprocessedQueue sync.RWMutex
	lockIsIngestionEnabledFromUfxFileNotificationQueue      sync.RWMutex
	lockIsKafkaIngestionEnabledForPaymentTransactions       sync.RWMutex
	lockIsKafkaPublishingEnableForAcquiringHostTransactions sync.RWMutex
	lockToggleOffIngestionFromBankingCirclePayments         sync.RWMutex
}

// IsIngestionEnabledFromBankingCircleUncheckedQueue calls IsIngestionEnabledFromBankingCircleUncheckedQueueFunc.
func (mock *FeatureFlagServiceMock) IsIngestionEnabledFromBankingCircleUncheckedQueue() bool {
	if mock.IsIngestionEnabledFromBankingCircleUncheckedQueueFunc == nil {
		panic("FeatureFlagServiceMock.IsIngestionEnabledFromBankingCircleUncheckedQueueFunc: method is nil but FeatureFlagService.IsIngestionEnabledFromBankingCircleUncheckedQueue was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsIngestionEnabledFromBankingCircleUncheckedQueue.Lock()
	mock.calls.IsIngestionEnabledFromBankingCircleUncheckedQueue = append(mock.calls.IsIngestionEnabledFromBankingCircleUncheckedQueue, callInfo)
	mock.lockIsIngestionEnabledFromBankingCircleUncheckedQueue.Unlock()
	return mock.IsIngestionEnabledFromBankingCircleUncheckedQueueFunc()
}

// IsIngestionEnabledFromBankingCircleUncheckedQueueCalls gets all the calls that were made to IsIngestionEnabledFromBankingCircleUncheckedQueue.
// Check the length with:
//
//	len(mockedFeatureFlagService.IsIngestionEnabledFromBankingCircleUncheckedQueueCalls())
func (mock *FeatureFlagServiceMock) IsIngestionEnabledFromBankingCircleUncheckedQueueCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsIngestionEnabledFromBankingCircleUncheckedQueue.RLock()
	calls = mock.calls.IsIngestionEnabledFromBankingCircleUncheckedQueue
	mock.lockIsIngestionEnabledFromBankingCircleUncheckedQueue.RUnlock()
	return calls
}

// IsIngestionEnabledFromBankingCircleUnprocessedQueue calls IsIngestionEnabledFromBankingCircleUnprocessedQueueFunc.
func (mock *FeatureFlagServiceMock) IsIngestionEnabledFromBankingCircleUnprocessedQueue() bool {
	if mock.IsIngestionEnabledFromBankingCircleUnprocessedQueueFunc == nil {
		panic("FeatureFlagServiceMock.IsIngestionEnabledFromBankingCircleUnprocessedQueueFunc: method is nil but FeatureFlagService.IsIngestionEnabledFromBankingCircleUnprocessedQueue was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsIngestionEnabledFromBankingCircleUnprocessedQueue.Lock()
	mock.calls.IsIngestionEnabledFromBankingCircleUnprocessedQueue = append(mock.calls.IsIngestionEnabledFromBankingCircleUnprocessedQueue, callInfo)
	mock.lockIsIngestionEnabledFromBankingCircleUnprocessedQueue.Unlock()
	return mock.IsIngestionEnabledFromBankingCircleUnprocessedQueueFunc()
}

// IsIngestionEnabledFromBankingCircleUnprocessedQueueCalls gets all the calls that were made to IsIngestionEnabledFromBankingCircleUnprocessedQueue.
// Check the length with:
//
//	len(mockedFeatureFlagService.IsIngestionEnabledFromBankingCircleUnprocessedQueueCalls())
func (mock *FeatureFlagServiceMock) IsIngestionEnabledFromBankingCircleUnprocessedQueueCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsIngestionEnabledFromBankingCircleUnprocessedQueue.RLock()
	calls = mock.calls.IsIngestionEnabledFromBankingCircleUnprocessedQueue
	mock.lockIsIngestionEnabledFromBankingCircleUnprocessedQueue.RUnlock()
	return calls
}

// IsIngestionEnabledFromUfxFileNotificationQueue calls IsIngestionEnabledFromUfxFileNotificationQueueFunc.
func (mock *FeatureFlagServiceMock) IsIngestionEnabledFromUfxFileNotificationQueue() bool {
	if mock.IsIngestionEnabledFromUfxFileNotificationQueueFunc == nil {
		panic("FeatureFlagServiceMock.IsIngestionEnabledFromUfxFileNotificationQueueFunc: method is nil but FeatureFlagService.IsIngestionEnabledFromUfxFileNotificationQueue was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsIngestionEnabledFromUfxFileNotificationQueue.Lock()
	mock.calls.IsIngestionEnabledFromUfxFileNotificationQueue = append(mock.calls.IsIngestionEnabledFromUfxFileNotificationQueue, callInfo)
	mock.lockIsIngestionEnabledFromUfxFileNotificationQueue.Unlock()
	return mock.IsIngestionEnabledFromUfxFileNotificationQueueFunc()
}

// IsIngestionEnabledFromUfxFileNotificationQueueCalls gets all the calls that were made to IsIngestionEnabledFromUfxFileNotificationQueue.
// Check the length with:
//
//	len(mockedFeatureFlagService.IsIngestionEnabledFromUfxFileNotificationQueueCalls())
func (mock *FeatureFlagServiceMock) IsIngestionEnabledFromUfxFileNotificationQueueCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsIngestionEnabledFromUfxFileNotificationQueue.RLock()
	calls = mock.calls.IsIngestionEnabledFromUfxFileNotificationQueue
	mock.lockIsIngestionEnabledFromUfxFileNotificationQueue.RUnlock()
	return calls
}

// IsKafkaIngestionEnabledForPaymentTransactions calls IsKafkaIngestionEnabledForPaymentTransactionsFunc.
func (mock *FeatureFlagServiceMock) IsKafkaIngestionEnabledForPaymentTransactions() bool {
	if mock.IsKafkaIngestionEnabledForPaymentTransactionsFunc == nil {
		panic("FeatureFlagServiceMock.IsKafkaIngestionEnabledForPaymentTransactionsFunc: method is nil but FeatureFlagService.IsKafkaIngestionEnabledForPaymentTransactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsKafkaIngestionEnabledForPaymentTransactions.Lock()
	mock.calls.IsKafkaIngestionEnabledForPaymentTransactions = append(mock.calls.IsKafkaIngestionEnabledForPaymentTransactions, callInfo)
	mock.lockIsKafkaIngestionEnabledForPaymentTransactions.Unlock()
	return mock.IsKafkaIngestionEnabledForPaymentTransactionsFunc()
}

// IsKafkaIngestionEnabledForPaymentTransactionsCalls gets all the calls that were made to IsKafkaIngestionEnabledForPaymentTransactions.
// Check the length with:
//
//	len(mockedFeatureFlagService.IsKafkaIngestionEnabledForPaymentTransactionsCalls())
func (mock *FeatureFlagServiceMock) IsKafkaIngestionEnabledForPaymentTransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsKafkaIngestionEnabledForPaymentTransactions.RLock()
	calls = mock.calls.IsKafkaIngestionEnabledForPaymentTransactions
	mock.lockIsKafkaIngestionEnabledForPaymentTransactions.RUnlock()
	return calls
}

// IsKafkaPublishingEnableForAcquiringHostTransactions calls IsKafkaPublishingEnableForAcquiringHostTransactionsFunc.
func (mock *FeatureFlagServiceMock) IsKafkaPublishingEnableForAcquiringHostTransactions() bool {
	if mock.IsKafkaPublishingEnableForAcquiringHostTransactionsFunc == nil {
		panic("FeatureFlagServiceMock.IsKafkaPublishingEnableForAcquiringHostTransactionsFunc: method is nil but FeatureFlagService.IsKafkaPublishingEnableForAcquiringHostTransactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsKafkaPublishingEnableForAcquiringHostTransactions.Lock()
	mock.calls.IsKafkaPublishingEnableForAcquiringHostTransactions = append(mock.calls.IsKafkaPublishingEnableForAcquiringHostTransactions, callInfo)
	mock.lockIsKafkaPublishingEnableForAcquiringHostTransactions.Unlock()
	return mock.IsKafkaPublishingEnableForAcquiringHostTransactionsFunc()
}

// IsKafkaPublishingEnableForAcquiringHostTransactionsCalls gets all the calls that were made to IsKafkaPublishingEnableForAcquiringHostTransactions.
// Check the length with:
//
//	len(mockedFeatureFlagService.IsKafkaPublishingEnableForAcquiringHostTransactionsCalls())
func (mock *FeatureFlagServiceMock) IsKafkaPublishingEnableForAcquiringHostTransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsKafkaPublishingEnableForAcquiringHostTransactions.RLock()
	calls = mock.calls.IsKafkaPublishingEnableForAcquiringHostTransactions
	mock.lockIsKafkaPublishingEnableForAcquiringHostTransactions.RUnlock()
	return calls
}

// ToggleOffIngestionFromBankingCirclePayments calls ToggleOffIngestionFromBankingCirclePaymentsFunc.
func (mock *FeatureFlagServiceMock) ToggleOffIngestionFromBankingCirclePayments(ctx context.Context) error {
	if mock.ToggleOffIngestionFromBankingCirclePaymentsFunc == nil {
		panic("FeatureFlagServiceMock.ToggleOffIngestionFromBankingCirclePaymentsFunc: method is nil but FeatureFlagService.ToggleOffIngestionFromBankingCirclePayments was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockToggleOffIngestionFromBankingCirclePayments.Lock()
	mock.calls.ToggleOffIngestionFromBankingCirclePayments = append(mock.calls.ToggleOffIngestionFromBankingCirclePayments, callInfo)
	mock.lockToggleOffIngestionFromBankingCirclePayments.Unlock()
	return mock.ToggleOffIngestionFromBankingCirclePaymentsFunc(ctx)
}

// ToggleOffIngestionFromBankingCirclePaymentsCalls gets all the calls that were made to ToggleOffIngestionFromBankingCirclePayments.
// Check the length with:
//
//	len(mockedFeatureFlagService.ToggleOffIngestionFromBankingCirclePaymentsCalls())
func (mock *FeatureFlagServiceMock) ToggleOffIngestionFromBankingCirclePaymentsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockToggleOffIngestionFromBankingCirclePayments.RLock()
	calls = mock.calls.ToggleOffIngestionFromBankingCirclePayments
	mock.lockToggleOffIngestionFromBankingCirclePayments.RUnlock()
	return calls
}
