// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/saltpay/settlements-payments-system/internal/domain/models"
	"github.com/saltpay/settlements-payments-system/internal/domain/ports"
	"sync"
)

// Ensure, that StorePaymentInstructionToRepoMock does implement ports.StorePaymentInstructionToRepo.
// If this is not the case, regenerate this file with moq.
var _ ports.StorePaymentInstructionToRepo = &StorePaymentInstructionToRepoMock{}

// StorePaymentInstructionToRepoMock is a mock implementation of ports.StorePaymentInstructionToRepo.
//
// 	func TestSomethingThatUsesStorePaymentInstructionToRepo(t *testing.T) {
//
// 		// make and configure a mocked ports.StorePaymentInstructionToRepo
// 		mockedStorePaymentInstructionToRepo := &StorePaymentInstructionToRepoMock{
// 			StoreFunc: func(ctx context.Context, instruction models.PaymentInstruction) error {
// 				panic("mock out the Store method")
// 			},
// 			UpdatePaymentFunc: func(ctx context.Context, id models.PaymentInstructionID, status models.PaymentInstructionStatus, event models.PaymentInstructionEvent) error {
// 				panic("mock out the UpdatePayment method")
// 			},
// 		}
//
// 		// use mockedStorePaymentInstructionToRepo in code that requires ports.StorePaymentInstructionToRepo
// 		// and then make assertions.
//
// 	}
type StorePaymentInstructionToRepoMock struct {
	// StoreFunc mocks the Store method.
	StoreFunc func(ctx context.Context, instruction models.PaymentInstruction) error

	// UpdatePaymentFunc mocks the UpdatePayment method.
	UpdatePaymentFunc func(ctx context.Context, id models.PaymentInstructionID, status models.PaymentInstructionStatus, event models.PaymentInstructionEvent) error

	// calls tracks calls to the methods.
	calls struct {
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Instruction is the instruction argument value.
			Instruction models.PaymentInstruction
		}
		// UpdatePayment holds details about calls to the UpdatePayment method.
		UpdatePayment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
			// Status is the status argument value.
			Status models.PaymentInstructionStatus
			// Event is the event argument value.
			Event models.PaymentInstructionEvent
		}
	}
	lockStore         sync.RWMutex
	lockUpdatePayment sync.RWMutex
}

// Store calls StoreFunc.
func (mock *StorePaymentInstructionToRepoMock) Store(ctx context.Context, instruction models.PaymentInstruction) error {
	if mock.StoreFunc == nil {
		panic("StorePaymentInstructionToRepoMock.StoreFunc: method is nil but StorePaymentInstructionToRepo.Store was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Instruction models.PaymentInstruction
	}{
		Ctx:         ctx,
		Instruction: instruction,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, instruction)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedStorePaymentInstructionToRepo.StoreCalls())
func (mock *StorePaymentInstructionToRepoMock) StoreCalls() []struct {
	Ctx         context.Context
	Instruction models.PaymentInstruction
} {
	var calls []struct {
		Ctx         context.Context
		Instruction models.PaymentInstruction
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// UpdatePayment calls UpdatePaymentFunc.
func (mock *StorePaymentInstructionToRepoMock) UpdatePayment(ctx context.Context, id models.PaymentInstructionID, status models.PaymentInstructionStatus, event models.PaymentInstructionEvent) error {
	if mock.UpdatePaymentFunc == nil {
		panic("StorePaymentInstructionToRepoMock.UpdatePaymentFunc: method is nil but StorePaymentInstructionToRepo.UpdatePayment was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     models.PaymentInstructionID
		Status models.PaymentInstructionStatus
		Event  models.PaymentInstructionEvent
	}{
		Ctx:    ctx,
		ID:     id,
		Status: status,
		Event:  event,
	}
	mock.lockUpdatePayment.Lock()
	mock.calls.UpdatePayment = append(mock.calls.UpdatePayment, callInfo)
	mock.lockUpdatePayment.Unlock()
	return mock.UpdatePaymentFunc(ctx, id, status, event)
}

// UpdatePaymentCalls gets all the calls that were made to UpdatePayment.
// Check the length with:
//     len(mockedStorePaymentInstructionToRepo.UpdatePaymentCalls())
func (mock *StorePaymentInstructionToRepoMock) UpdatePaymentCalls() []struct {
	Ctx    context.Context
	ID     models.PaymentInstructionID
	Status models.PaymentInstructionStatus
	Event  models.PaymentInstructionEvent
} {
	var calls []struct {
		Ctx    context.Context
		ID     models.PaymentInstructionID
		Status models.PaymentInstructionStatus
		Event  models.PaymentInstructionEvent
	}
	mock.lockUpdatePayment.RLock()
	calls = mock.calls.UpdatePayment
	mock.lockUpdatePayment.RUnlock()
	return calls
}
