// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/saltpay/settlements-payments-system/internal/adapters/payment_store"
	"github.com/saltpay/settlements-payments-system/internal/domain/models"
	"sync"
)

// Ensure, that PaymentRepoObservabilityMock does implement payment_store.PaymentRepoObservability.
// If this is not the case, regenerate this file with moq.
var _ payment_store.PaymentRepoObservability = &PaymentRepoObservabilityMock{}

// PaymentRepoObservabilityMock is a mock implementation of payment_store.PaymentRepoObservability.
//
// 	func TestSomethingThatUsesPaymentRepoObservability(t *testing.T) {
//
// 		// make and configure a mocked payment_store.PaymentRepoObservability
// 		mockedPaymentRepoObservability := &PaymentRepoObservabilityMock{
// 			FailedGetFunc: func(ctx context.Context, id models.PaymentInstructionID, err error)  {
// 				panic("mock out the FailedGet method")
// 			},
// 			FailedStoreFunc: func(ctx context.Context, id models.PaymentInstructionID, contractNumber string, err error)  {
// 				panic("mock out the FailedStore method")
// 			},
// 			FailedUpdateFunc: func(ctx context.Context, id models.PaymentInstructionID, err error)  {
// 				panic("mock out the FailedUpdate method")
// 			},
// 			GetSuccessfulFunc: func(ctx context.Context, id models.PaymentInstructionID, responseTime int64)  {
// 				panic("mock out the GetSuccessful method")
// 			},
// 			GotReportFunc: func(ctx context.Context, duration int64)  {
// 				panic("mock out the GotReport method")
// 			},
// 			PaymentInstructionNotFoundFunc: func(ctx context.Context, id models.PaymentInstructionID)  {
// 				panic("mock out the PaymentInstructionNotFound method")
// 			},
// 			ReceivedGetInstructionFunc: func(ctx context.Context, id models.PaymentInstructionID)  {
// 				panic("mock out the ReceivedGetInstruction method")
// 			},
// 			ReceivedStoreInstructionFunc: func(ctx context.Context, id models.PaymentInstructionID)  {
// 				panic("mock out the ReceivedStoreInstruction method")
// 			},
// 			StoreSuccessfulFunc: func(ctx context.Context, id models.PaymentInstructionID, responseTime int64)  {
// 				panic("mock out the StoreSuccessful method")
// 			},
// 			UpdateSuccessfulFunc: func(ctx context.Context, paymentInstructionID models.PaymentInstructionID, responseTime int64)  {
// 				panic("mock out the UpdateSuccessful method")
// 			},
// 		}
//
// 		// use mockedPaymentRepoObservability in code that requires payment_store.PaymentRepoObservability
// 		// and then make assertions.
//
// 	}
type PaymentRepoObservabilityMock struct {
	// FailedGetFunc mocks the FailedGet method.
	FailedGetFunc func(ctx context.Context, id models.PaymentInstructionID, err error)

	// FailedStoreFunc mocks the FailedStore method.
	FailedStoreFunc func(ctx context.Context, id models.PaymentInstructionID, contractNumber string, err error)

	// FailedUpdateFunc mocks the FailedUpdate method.
	FailedUpdateFunc func(ctx context.Context, id models.PaymentInstructionID, err error)

	// GetSuccessfulFunc mocks the GetSuccessful method.
	GetSuccessfulFunc func(ctx context.Context, id models.PaymentInstructionID, responseTime int64)

	// GotReportFunc mocks the GotReport method.
	GotReportFunc func(ctx context.Context, duration int64)

	// PaymentInstructionNotFoundFunc mocks the PaymentInstructionNotFound method.
	PaymentInstructionNotFoundFunc func(ctx context.Context, id models.PaymentInstructionID)

	// ReceivedGetInstructionFunc mocks the ReceivedGetInstruction method.
	ReceivedGetInstructionFunc func(ctx context.Context, id models.PaymentInstructionID)

	// ReceivedStoreInstructionFunc mocks the ReceivedStoreInstruction method.
	ReceivedStoreInstructionFunc func(ctx context.Context, id models.PaymentInstructionID)

	// StoreSuccessfulFunc mocks the StoreSuccessful method.
	StoreSuccessfulFunc func(ctx context.Context, id models.PaymentInstructionID, responseTime int64)

	// UpdateSuccessfulFunc mocks the UpdateSuccessful method.
	UpdateSuccessfulFunc func(ctx context.Context, paymentInstructionID models.PaymentInstructionID, responseTime int64)

	// calls tracks calls to the methods.
	calls struct {
		// FailedGet holds details about calls to the FailedGet method.
		FailedGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
			// Err is the err argument value.
			Err error
		}
		// FailedStore holds details about calls to the FailedStore method.
		FailedStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
			// ContractNumber is the contractNumber argument value.
			ContractNumber string
			// Err is the err argument value.
			Err error
		}
		// FailedUpdate holds details about calls to the FailedUpdate method.
		FailedUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
			// Err is the err argument value.
			Err error
		}
		// GetSuccessful holds details about calls to the GetSuccessful method.
		GetSuccessful []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
			// ResponseTime is the responseTime argument value.
			ResponseTime int64
		}
		// GotReport holds details about calls to the GotReport method.
		GotReport []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Duration is the duration argument value.
			Duration int64
		}
		// PaymentInstructionNotFound holds details about calls to the PaymentInstructionNotFound method.
		PaymentInstructionNotFound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
		}
		// ReceivedGetInstruction holds details about calls to the ReceivedGetInstruction method.
		ReceivedGetInstruction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
		}
		// ReceivedStoreInstruction holds details about calls to the ReceivedStoreInstruction method.
		ReceivedStoreInstruction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
		}
		// StoreSuccessful holds details about calls to the StoreSuccessful method.
		StoreSuccessful []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.PaymentInstructionID
			// ResponseTime is the responseTime argument value.
			ResponseTime int64
		}
		// UpdateSuccessful holds details about calls to the UpdateSuccessful method.
		UpdateSuccessful []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PaymentInstructionID is the paymentInstructionID argument value.
			PaymentInstructionID models.PaymentInstructionID
			// ResponseTime is the responseTime argument value.
			ResponseTime int64
		}
	}
	lockFailedGet                  sync.RWMutex
	lockFailedStore                sync.RWMutex
	lockFailedUpdate               sync.RWMutex
	lockGetSuccessful              sync.RWMutex
	lockGotReport                  sync.RWMutex
	lockPaymentInstructionNotFound sync.RWMutex
	lockReceivedGetInstruction     sync.RWMutex
	lockReceivedStoreInstruction   sync.RWMutex
	lockStoreSuccessful            sync.RWMutex
	lockUpdateSuccessful           sync.RWMutex
}

// FailedGet calls FailedGetFunc.
func (mock *PaymentRepoObservabilityMock) FailedGet(ctx context.Context, id models.PaymentInstructionID, err error) {
	if mock.FailedGetFunc == nil {
		panic("PaymentRepoObservabilityMock.FailedGetFunc: method is nil but PaymentRepoObservability.FailedGet was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
		Err error
	}{
		Ctx: ctx,
		ID:  id,
		Err: err,
	}
	mock.lockFailedGet.Lock()
	mock.calls.FailedGet = append(mock.calls.FailedGet, callInfo)
	mock.lockFailedGet.Unlock()
	mock.FailedGetFunc(ctx, id, err)
}

// FailedGetCalls gets all the calls that were made to FailedGet.
// Check the length with:
//     len(mockedPaymentRepoObservability.FailedGetCalls())
func (mock *PaymentRepoObservabilityMock) FailedGetCalls() []struct {
	Ctx context.Context
	ID  models.PaymentInstructionID
	Err error
} {
	var calls []struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
		Err error
	}
	mock.lockFailedGet.RLock()
	calls = mock.calls.FailedGet
	mock.lockFailedGet.RUnlock()
	return calls
}

// FailedStore calls FailedStoreFunc.
func (mock *PaymentRepoObservabilityMock) FailedStore(ctx context.Context, id models.PaymentInstructionID, contractNumber string, err error) {
	if mock.FailedStoreFunc == nil {
		panic("PaymentRepoObservabilityMock.FailedStoreFunc: method is nil but PaymentRepoObservability.FailedStore was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		ID             models.PaymentInstructionID
		ContractNumber string
		Err            error
	}{
		Ctx:            ctx,
		ID:             id,
		ContractNumber: contractNumber,
		Err:            err,
	}
	mock.lockFailedStore.Lock()
	mock.calls.FailedStore = append(mock.calls.FailedStore, callInfo)
	mock.lockFailedStore.Unlock()
	mock.FailedStoreFunc(ctx, id, contractNumber, err)
}

// FailedStoreCalls gets all the calls that were made to FailedStore.
// Check the length with:
//     len(mockedPaymentRepoObservability.FailedStoreCalls())
func (mock *PaymentRepoObservabilityMock) FailedStoreCalls() []struct {
	Ctx            context.Context
	ID             models.PaymentInstructionID
	ContractNumber string
	Err            error
} {
	var calls []struct {
		Ctx            context.Context
		ID             models.PaymentInstructionID
		ContractNumber string
		Err            error
	}
	mock.lockFailedStore.RLock()
	calls = mock.calls.FailedStore
	mock.lockFailedStore.RUnlock()
	return calls
}

// FailedUpdate calls FailedUpdateFunc.
func (mock *PaymentRepoObservabilityMock) FailedUpdate(ctx context.Context, id models.PaymentInstructionID, err error) {
	if mock.FailedUpdateFunc == nil {
		panic("PaymentRepoObservabilityMock.FailedUpdateFunc: method is nil but PaymentRepoObservability.FailedUpdate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
		Err error
	}{
		Ctx: ctx,
		ID:  id,
		Err: err,
	}
	mock.lockFailedUpdate.Lock()
	mock.calls.FailedUpdate = append(mock.calls.FailedUpdate, callInfo)
	mock.lockFailedUpdate.Unlock()
	mock.FailedUpdateFunc(ctx, id, err)
}

// FailedUpdateCalls gets all the calls that were made to FailedUpdate.
// Check the length with:
//     len(mockedPaymentRepoObservability.FailedUpdateCalls())
func (mock *PaymentRepoObservabilityMock) FailedUpdateCalls() []struct {
	Ctx context.Context
	ID  models.PaymentInstructionID
	Err error
} {
	var calls []struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
		Err error
	}
	mock.lockFailedUpdate.RLock()
	calls = mock.calls.FailedUpdate
	mock.lockFailedUpdate.RUnlock()
	return calls
}

// GetSuccessful calls GetSuccessfulFunc.
func (mock *PaymentRepoObservabilityMock) GetSuccessful(ctx context.Context, id models.PaymentInstructionID, responseTime int64) {
	if mock.GetSuccessfulFunc == nil {
		panic("PaymentRepoObservabilityMock.GetSuccessfulFunc: method is nil but PaymentRepoObservability.GetSuccessful was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ID           models.PaymentInstructionID
		ResponseTime int64
	}{
		Ctx:          ctx,
		ID:           id,
		ResponseTime: responseTime,
	}
	mock.lockGetSuccessful.Lock()
	mock.calls.GetSuccessful = append(mock.calls.GetSuccessful, callInfo)
	mock.lockGetSuccessful.Unlock()
	mock.GetSuccessfulFunc(ctx, id, responseTime)
}

// GetSuccessfulCalls gets all the calls that were made to GetSuccessful.
// Check the length with:
//     len(mockedPaymentRepoObservability.GetSuccessfulCalls())
func (mock *PaymentRepoObservabilityMock) GetSuccessfulCalls() []struct {
	Ctx          context.Context
	ID           models.PaymentInstructionID
	ResponseTime int64
} {
	var calls []struct {
		Ctx          context.Context
		ID           models.PaymentInstructionID
		ResponseTime int64
	}
	mock.lockGetSuccessful.RLock()
	calls = mock.calls.GetSuccessful
	mock.lockGetSuccessful.RUnlock()
	return calls
}

// GotReport calls GotReportFunc.
func (mock *PaymentRepoObservabilityMock) GotReport(ctx context.Context, duration int64) {
	if mock.GotReportFunc == nil {
		panic("PaymentRepoObservabilityMock.GotReportFunc: method is nil but PaymentRepoObservability.GotReport was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Duration int64
	}{
		Ctx:      ctx,
		Duration: duration,
	}
	mock.lockGotReport.Lock()
	mock.calls.GotReport = append(mock.calls.GotReport, callInfo)
	mock.lockGotReport.Unlock()
	mock.GotReportFunc(ctx, duration)
}

// GotReportCalls gets all the calls that were made to GotReport.
// Check the length with:
//     len(mockedPaymentRepoObservability.GotReportCalls())
func (mock *PaymentRepoObservabilityMock) GotReportCalls() []struct {
	Ctx      context.Context
	Duration int64
} {
	var calls []struct {
		Ctx      context.Context
		Duration int64
	}
	mock.lockGotReport.RLock()
	calls = mock.calls.GotReport
	mock.lockGotReport.RUnlock()
	return calls
}

// PaymentInstructionNotFound calls PaymentInstructionNotFoundFunc.
func (mock *PaymentRepoObservabilityMock) PaymentInstructionNotFound(ctx context.Context, id models.PaymentInstructionID) {
	if mock.PaymentInstructionNotFoundFunc == nil {
		panic("PaymentRepoObservabilityMock.PaymentInstructionNotFoundFunc: method is nil but PaymentRepoObservability.PaymentInstructionNotFound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockPaymentInstructionNotFound.Lock()
	mock.calls.PaymentInstructionNotFound = append(mock.calls.PaymentInstructionNotFound, callInfo)
	mock.lockPaymentInstructionNotFound.Unlock()
	mock.PaymentInstructionNotFoundFunc(ctx, id)
}

// PaymentInstructionNotFoundCalls gets all the calls that were made to PaymentInstructionNotFound.
// Check the length with:
//     len(mockedPaymentRepoObservability.PaymentInstructionNotFoundCalls())
func (mock *PaymentRepoObservabilityMock) PaymentInstructionNotFoundCalls() []struct {
	Ctx context.Context
	ID  models.PaymentInstructionID
} {
	var calls []struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
	}
	mock.lockPaymentInstructionNotFound.RLock()
	calls = mock.calls.PaymentInstructionNotFound
	mock.lockPaymentInstructionNotFound.RUnlock()
	return calls
}

// ReceivedGetInstruction calls ReceivedGetInstructionFunc.
func (mock *PaymentRepoObservabilityMock) ReceivedGetInstruction(ctx context.Context, id models.PaymentInstructionID) {
	if mock.ReceivedGetInstructionFunc == nil {
		panic("PaymentRepoObservabilityMock.ReceivedGetInstructionFunc: method is nil but PaymentRepoObservability.ReceivedGetInstruction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockReceivedGetInstruction.Lock()
	mock.calls.ReceivedGetInstruction = append(mock.calls.ReceivedGetInstruction, callInfo)
	mock.lockReceivedGetInstruction.Unlock()
	mock.ReceivedGetInstructionFunc(ctx, id)
}

// ReceivedGetInstructionCalls gets all the calls that were made to ReceivedGetInstruction.
// Check the length with:
//     len(mockedPaymentRepoObservability.ReceivedGetInstructionCalls())
func (mock *PaymentRepoObservabilityMock) ReceivedGetInstructionCalls() []struct {
	Ctx context.Context
	ID  models.PaymentInstructionID
} {
	var calls []struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
	}
	mock.lockReceivedGetInstruction.RLock()
	calls = mock.calls.ReceivedGetInstruction
	mock.lockReceivedGetInstruction.RUnlock()
	return calls
}

// ReceivedStoreInstruction calls ReceivedStoreInstructionFunc.
func (mock *PaymentRepoObservabilityMock) ReceivedStoreInstruction(ctx context.Context, id models.PaymentInstructionID) {
	if mock.ReceivedStoreInstructionFunc == nil {
		panic("PaymentRepoObservabilityMock.ReceivedStoreInstructionFunc: method is nil but PaymentRepoObservability.ReceivedStoreInstruction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockReceivedStoreInstruction.Lock()
	mock.calls.ReceivedStoreInstruction = append(mock.calls.ReceivedStoreInstruction, callInfo)
	mock.lockReceivedStoreInstruction.Unlock()
	mock.ReceivedStoreInstructionFunc(ctx, id)
}

// ReceivedStoreInstructionCalls gets all the calls that were made to ReceivedStoreInstruction.
// Check the length with:
//     len(mockedPaymentRepoObservability.ReceivedStoreInstructionCalls())
func (mock *PaymentRepoObservabilityMock) ReceivedStoreInstructionCalls() []struct {
	Ctx context.Context
	ID  models.PaymentInstructionID
} {
	var calls []struct {
		Ctx context.Context
		ID  models.PaymentInstructionID
	}
	mock.lockReceivedStoreInstruction.RLock()
	calls = mock.calls.ReceivedStoreInstruction
	mock.lockReceivedStoreInstruction.RUnlock()
	return calls
}

// StoreSuccessful calls StoreSuccessfulFunc.
func (mock *PaymentRepoObservabilityMock) StoreSuccessful(ctx context.Context, id models.PaymentInstructionID, responseTime int64) {
	if mock.StoreSuccessfulFunc == nil {
		panic("PaymentRepoObservabilityMock.StoreSuccessfulFunc: method is nil but PaymentRepoObservability.StoreSuccessful was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ID           models.PaymentInstructionID
		ResponseTime int64
	}{
		Ctx:          ctx,
		ID:           id,
		ResponseTime: responseTime,
	}
	mock.lockStoreSuccessful.Lock()
	mock.calls.StoreSuccessful = append(mock.calls.StoreSuccessful, callInfo)
	mock.lockStoreSuccessful.Unlock()
	mock.StoreSuccessfulFunc(ctx, id, responseTime)
}

// StoreSuccessfulCalls gets all the calls that were made to StoreSuccessful.
// Check the length with:
//     len(mockedPaymentRepoObservability.StoreSuccessfulCalls())
func (mock *PaymentRepoObservabilityMock) StoreSuccessfulCalls() []struct {
	Ctx          context.Context
	ID           models.PaymentInstructionID
	ResponseTime int64
} {
	var calls []struct {
		Ctx          context.Context
		ID           models.PaymentInstructionID
		ResponseTime int64
	}
	mock.lockStoreSuccessful.RLock()
	calls = mock.calls.StoreSuccessful
	mock.lockStoreSuccessful.RUnlock()
	return calls
}

// UpdateSuccessful calls UpdateSuccessfulFunc.
func (mock *PaymentRepoObservabilityMock) UpdateSuccessful(ctx context.Context, paymentInstructionID models.PaymentInstructionID, responseTime int64) {
	if mock.UpdateSuccessfulFunc == nil {
		panic("PaymentRepoObservabilityMock.UpdateSuccessfulFunc: method is nil but PaymentRepoObservability.UpdateSuccessful was just called")
	}
	callInfo := struct {
		Ctx                  context.Context
		PaymentInstructionID models.PaymentInstructionID
		ResponseTime         int64
	}{
		Ctx:                  ctx,
		PaymentInstructionID: paymentInstructionID,
		ResponseTime:         responseTime,
	}
	mock.lockUpdateSuccessful.Lock()
	mock.calls.UpdateSuccessful = append(mock.calls.UpdateSuccessful, callInfo)
	mock.lockUpdateSuccessful.Unlock()
	mock.UpdateSuccessfulFunc(ctx, paymentInstructionID, responseTime)
}

// UpdateSuccessfulCalls gets all the calls that were made to UpdateSuccessful.
// Check the length with:
//     len(mockedPaymentRepoObservability.UpdateSuccessfulCalls())
func (mock *PaymentRepoObservabilityMock) UpdateSuccessfulCalls() []struct {
	Ctx                  context.Context
	PaymentInstructionID models.PaymentInstructionID
	ResponseTime         int64
} {
	var calls []struct {
		Ctx                  context.Context
		PaymentInstructionID models.PaymentInstructionID
		ResponseTime         int64
	}
	mock.lockUpdateSuccessful.RLock()
	calls = mock.calls.UpdateSuccessful
	mock.lockUpdateSuccessful.RUnlock()
	return calls
}
